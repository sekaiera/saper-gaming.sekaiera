<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Сапёр</title>
  <style>
    body {
      background: #c0c0c0;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      justify-content: center;
      margin-top: 40px;
    }

    .container {
      border: 4px solid #fff;
      box-shadow: inset -2px -2px 0 #808080, inset 2px 2px 0 #fff;
      background: #c0c0c0;
      padding: 10px;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #808080;
      padding: 5px 10px;
      border: 2px solid #fff;
      box-shadow: inset -2px -2px 0 #404040, inset 2px 2px 0 #fff;
    }

    .counter, .timer {
      font-size: 24px;
      background: black;
      color: red;
      padding: 5px 10px;
      font-family: monospace;
      border: 2px inset #808080;
    }

    .face {
      font-size: 24px;
      cursor: pointer;
      border: 2px outset #fff;
      background: #c0c0c0;
      padding: 4px 10px;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(9, 30px);
      grid-template-rows: repeat(9, 30px);
      gap: 1px;
      margin-top: 10px;
    }

    .cell {
      width: 30px;
      height: 30px;
      background: #c0c0c0;
      border: 2px outset #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      user-select: none;
    }

    .cell.open {
      background: #e0e0e0;
      border: 2px inset #808080;
      cursor: default;
    }

    .cell.flag {
      color: red;
    }

    .cell.mine {
      background: red;
    }

  </style>
</head>
<body>

<div class="container">
  <div class="top-bar">
    <div class="counter" id="minesLeft">010</div>
    <div class="face" id="resetBtn">😊</div>
    <div class="timer" id="timer">000</div>
  </div>
  <div id="board"></div>
</div>

<script>
  const rows = 9;
  const cols = 9;
  const mines = 10;

  let board = [];
  let mineCount = mines;
  let timer = 0;
  let timerInterval;
  let started = false;
  let gameOver = false;

  const boardEl = document.getElementById("board");
  const resetBtn = document.getElementById("resetBtn");
  const minesLeftEl = document.getElementById("minesLeft");
  const timerEl = document.getElementById("timer");

  function pad(num) {
    return num.toString().padStart(3, "0");
  }

  function startTimer() {
    timerInterval = setInterval(() => {
      timer++;
      timerEl.textContent = pad(timer);
    }, 1000);
  }

  function stopTimer() {
    clearInterval(timerInterval);
  }

  function resetGame() {
    board = [];
    started = false;
    gameOver = false;
    timer = 0;
    mineCount = mines;
    timerEl.textContent = "000";
    minesLeftEl.textContent = pad(mineCount);
    resetBtn.textContent = "😊";
    clearInterval(timerInterval);
    boardEl.innerHTML = "";

    for (let r = 0; r < rows; r++) {
      board[r] = [];
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.dataset.row = r;
        cell.dataset.col = c;

        cell.addEventListener("click", handleLeftClick);
        cell.addEventListener("contextmenu", handleRightClick);

        boardEl.appendChild(cell);
        board[r][c] = {
          el: cell,
          mine: false,
          revealed: false,
          flagged: false,
          count: 0
        };
      }
    }
  }

  function placeMines(firstClickRow, firstClickCol) {
    let placed = 0;
    while (placed < mines) {
      const r = Math.floor(Math.random() * rows);
      const c = Math.floor(Math.random() * cols);
      if ((r === firstClickRow && c === firstClickCol) || board[r][c].mine) continue;
      board[r][c].mine = true;
      placed++;
    }

    // calculate numbers
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (board[r][c].mine) continue;
        let count = 0;
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            const nr = r + dr;
            const nc = c + dc;
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && board[nr][nc].mine) {
              count++;
            }
          }
        }
        board[r][c].count = count;
      }
    }
  }

  function handleLeftClick(e) {
    if (gameOver) return;

    const row = +this.dataset.row;
    const col = +this.dataset.col;
    const cell = board[row][col];

    if (cell.revealed || cell.flagged) return;

    if (!started) {
      placeMines(row, col);
      startTimer();
      started = true;
    }

    if (cell.mine) {
      revealAllMines();
      cell.el.classList.add("mine");
      cell.el.textContent = "💣";
      resetBtn.textContent = "☠️";
      gameOver = true;
      stopTimer();
      return;
    }

    revealCell(row, col);

    if (checkWin()) {
      resetBtn.textContent = "😎";
      gameOver = true;
      stopTimer();
    }
  }

  function handleRightClick(e) {
    e.preventDefault();
    if (gameOver) return;

    const row = +this.dataset.row;
    const col = +this.dataset.col;
    const cell = board[row][col];

    if (cell.revealed) return;

    cell.flagged = !cell.flagged;
    cell.el.textContent = cell.flagged ? "🚩" : "";
    cell.el.classList.toggle("flag");
    mineCount += cell.flagged ? -1 : 1;
    minesLeftEl.textContent = pad(mineCount);
  }

  function revealCell(row, col) {
    const cell = board[row][col];
    if (cell.revealed || cell.flagged) return;

    cell.revealed = true;
    cell.el.classList.add("open");

    if (cell.count > 0) {
      cell.el.textContent = cell.count;
    } else {
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          const nr = row + dr;
          const nc = col + dc;
          if (
            nr >= 0 && nr < rows &&
            nc >= 0 && nc < cols &&
            !(dr === 0 && dc === 0)
          ) {
            revealCell(nr, nc);
          }
        }
      }
    }
  }

  function revealAllMines() {
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const cell = board[r][c];
        if (cell.mine) {
          cell.el.classList.add("open");
          cell.el.textContent = "💣";
        }
      }
    }
  }

  function
